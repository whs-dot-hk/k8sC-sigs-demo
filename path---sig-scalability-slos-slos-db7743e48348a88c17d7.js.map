{"version":3,"sources":["webpack:///path---sig-scalability-slos-slos-db7743e48348a88c17d7.js","webpack:///./.cache/json/sig-scalability-slos-slos.json"],"names":["webpackJsonp","491","module","exports","data","markdownRemark","html","site","siteMetadata","sigs","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,wgRAAojRC,MAASC,cAAgBC,MAAA,ofAA2fC,aAAgBC,KAAA","file":"path---sig-scalability-slos-slos-db7743e48348a88c17d7.js","sourcesContent":["webpackJsonp([196072083135701],{\n\n/***/ 491:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>Kubernetes scalability and performance SLIs/SLOs</h1>\\n<h2>What Kubernetes guarantees?</h2>\\n<p>One of the important aspects of Kubernetes is its scalability and performance\\ncharacteristic. As Kubernetes user or operator/administrator of a cluster\\nyou would expect to have some guarantees in those areas.</p>\\n<p>The goal of this doc is to organize the guarantees that Kubernetes provides\\nin these areas.</p>\\n<h2>What do we require from SLIs/SLOs?</h2>\\n<p>We are going to define more SLIs and SLOs based on the most important indicators\\nin the system.</p>\\n<p>Our SLOs need to have the following properties:</p>\\n<ul>\\n<li><b> They need to be testable </b> <br/>\\nThat means that we need to have a benchmark to measure if it's met.</li>\\n<li><b> They need to be understandable for users </b> <br/>\\nIn particular, they need to be understandable for people not familiar\\nwith the system internals, i.e. their formulation can't depend on some\\narcane knowledge.</li>\\n</ul>\\n<p>However, we may introduce some internal (for developers only) SLIs, that\\nmay be useful for understanding performance characterstic of the system,\\nbut for which we don't provide any guarantees for users and thus may not\\nbe fully understandable for users.</p>\\n<p>On the other hand, we do NOT require that our SLOs:</p>\\n<ul>\\n<li>are measurable in a running cluster (though that's desired if possible) <br/>\\nIn other words, not SLOs need to be easily translatable to SLAs.\\nBeing able to benchmark is enough for us.</li>\\n</ul>\\n<h2>Types of SLOs</h2>\\n<p>While SLIs are very generic and don't really depend on anything (they just\\ndefine what and how we measure), it's not the case for SLOs.\\nSLOs provide guarantees, and satisfying them may depend on meeting some\\nspecific requirements.</p>\\n<p>As a result, we build our SLOs in \\\"you promise, we promise\\\" format.\\nThat means, that we provide you a guarantee only if you satisfy the requirement\\nthat we put on you.</p>\\n<p>As a consequence we introduce the two types of SLOs.</p>\\n<h3>Steady state SLOs</h3>\\n<p>With steady state SLOs, we provide guarantees about system's behavior during\\nnormal operations. We are able to provide much more guarantees in that situation.</p>\\n<pre><code class=\\\"language-Definition\\\">We define system to be in steady state when the cluster churn per second is &#x3C;= 20, where\\n\\nchurn = #(Pod spec creations/updates/deletions) + #(user originated requests) in a given second\\n</code></pre>\\n<h3>Burst SLO</h3>\\n<p>With burst SLOs, we provide guarantees on how system behaves under the heavy load\\n(when user wants the system to do something as quickly as possible not caring too\\nmuch about response time).</p>\\n<h2>Environment</h2>\\n<p>In order to meet the SLOs, system must run in the environment satisfying\\nthe following criteria:</p>\\n<ul>\\n<li>Runs a single or more appropriate sized master machines</li>\\n<li>Main etcd running on master machine(s)</li>\\n<li>Events are stored in a separate etcd running on the master machine(s)</li>\\n<li>Kubernetes version is at least X.Y.Z</li>\\n<li>...</li>\\n</ul>\\n<p><strong>TODO: Document other necessary configuration.</strong></p>\\n<h2>Thresholds</h2>\\n<p>To make the cluster eligible for SLO, users also can't have too many objects in\\ntheir clusters. More concretely, the number of different objects in the cluster\\nMUST satisfy thresholds defined in <a href=\\\"https://github.com/kubernetes/community/blob/master/sig-scalability/configs-and-limits/thresholds.md\\\">thresholds file</a>.</p>\\n<h2>Kubernetes SLIs/SLOs</h2>\\n<p>The currently existing SLIs/SLOs are enough to guarantee that cluster isn't\\ncompletely dead. However, the are not enough to satisfy user's needs in most\\nof the cases.</p>\\n<p>We are looking into extending the set of SLIs/SLOs to cover more parts of\\nKubernetes.</p>\\n<pre><code>Prerequisite: Kubernetes cluster is available and serving.\\n</code></pre>\\n<h3>Steady state SLIs/SLOs</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>Status</th>\\n<th>SLI</th>\\n<th>SLO</th>\\n<th>User stories, test scenarios, ...</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><strong>Official</strong></td>\\n<td>Latency\\n<sup>\\n<a href=\\\"#footnote1\\\">1</a>\\n</sup>\\n of mutating\\n<sup>\\n<a href=\\\"#footnote2\\\">2</a>\\n</sup>\\n API calls for single objects for every (resource, verb) pair, measured as 99th percentile over last 5 minutes</td>\\n<td>In default Kubernetes installation, for every (resource, verb) pair, excluding virtual and aggregated resources and Custom Resource Definitions, 99th percentile per cluster-day\\n<sup>\\n<a href=\\\"#footnote3\\\">3</a>\\n</sup>\\n &#x3C;= 1s</td>\\n<td><a href=\\\"./api_call_latency.md\\\">Details</a></td>\\n</tr>\\n<tr>\\n<td><strong>Official</strong></td>\\n<td>Latency\\n<sup>\\n<a href=\\\"#footnote1\\\">1</a>\\n</sup>\\n of non-streaming read-only\\n<sup>\\n<a href=\\\"#footnote3\\\">4</a>\\n</sup>\\n API calls for every (resource, scope\\n<sup>\\n<a href=\\\"#footnote4\\\">5</a>\\n</sup>\\n) pair, measured as 99th percentile over last 5 minutes</td>\\n<td>In default Kubernetes installation, for every (resource, scope) pair, excluding virtual and aggregated resources and Custom Resource Definitions, 99th percentile per cluster-day (a) &#x3C;= 1s if \\n<code>scope=resource</code>\\n (b) &#x3C;= 5s if \\n<code>scope=namespace</code>\\n (c) &#x3C;= 30s if \\n<code>scope=cluster</code></td>\\n<td><a href=\\\"./api_call_latency.md\\\">Details</a></td>\\n</tr>\\n<tr>\\n<td><strong>Official</strong></td>\\n<td>Startup latency of stateless\\n<sup>\\n<a href=\\\"#footnode6\\\">6</a>\\n</sup>\\n and schedulable\\n<sup>\\n<a href=\\\"#footnote7\\\">7</a>\\n</sup>\\n pods, excluding time to pull images and run init containers, measured from pod creation timestamp to when all its containers are reported as started and observed via watch, measured as 99th percentile over last 5 minutes</td>\\n<td>In default Kubernetes installation, 99th percentile per cluster-day &#x3C;= 5s</td>\\n<td><a href=\\\"./pod_startup_latency.md\\\">Details</a></td>\\n</tr>\\n</tbody>\\n</table>\\n<p><a name=\\\"footnote1\\\">[1]</a>By latency of API call in this doc we mean time\\nfrom the moment when apiserver gets the request to last byte of response sent\\nto the user.</p>\\n<p><a name=\\\"footnote2\\\">[2]</a>By mutating API calls we mean POST, PUT, DELETE\\nand PATCH.</p>\\n<p><a name=\\\"footnote3\\\">[3]</a> For the purpose of visualization it will be a\\nsliding window. However, for the purpose of reporting the SLO, it means one\\npoint per day (whether SLO was satisfied on a given day or not).</p>\\n<p><a name=\\\"footnote4\\\">[4]</a>By non-streaming read-only API calls we mean GET\\nrequests without <code>watch=true</code> option set. (Note that in Kubernetes internally\\nit translates to both GET and LIST calls).</p>\\n<p><a name=\\\"footnote5\\\">[5]</a>A scope of a request can be either (a) <code>resource</code>\\nif the request is about a single object, (b) <code>namespace</code> if it is about objects\\nfrom a single namespace or (c) <code>cluster</code> if it spawns objects from multiple\\nnamespaces.</p>\\n<p><a name=\\\"footnode6\\\">[6]</a>A <code>stateless pod</code> is defined as a pod that doesn't\\nmount volumes with sources other than secrets, config maps, downward API and\\nempty dir.</p>\\n<p><a name=\\\"footnode7\\\">[7]</a>By schedulable pod we mean a pod that can be\\nscheduled in the cluster without causing any preemption.</p>\\n<h3>Burst SLIs/SLOs</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>Status</th>\\n<th>SLI</th>\\n<th>SLO</th>\\n<th>User stories, test scenarios, ...</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>WIP</td>\\n<td>Time to start 30\\n*\\n#nodes pods, measured from test scenario start until observing last Pod as ready</td>\\n<td>Benchmark: when all images present on all Nodes, 99th percentile &#x3C;= X minutes</td>\\n<td><a href=\\\"./system_throughput.md\\\">Details</a></td>\\n</tr>\\n</tbody>\\n</table>\\n<h3>Other SLIs</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>Status</th>\\n<th>SLI</th>\\n<th>User stories, ...</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>WIP</td>\\n<td>Watch latency for every resource, (from the moment when object is stored in database to when it's ready to be sent to all watchers), measured as 99th percentile over last 5 minutes</td>\\n<td>TODO</td>\\n</tr>\\n<tr>\\n<td>WIP</td>\\n<td>Admission latency for each admission plugin type, measured as 99th percentile over last 5 minutes</td>\\n<td><a href=\\\"./api_extensions_latency.md\\\">Details</a></td>\\n</tr>\\n<tr>\\n<td>WIP</td>\\n<td>Webhook call latency for each webhook type, measured as 99th percentile over last 5 minutes</td>\\n<td><a href=\\\"./api_extensions_latency.md\\\">Details</a></td>\\n</tr>\\n<tr>\\n<td>WIP</td>\\n<td>Initializer latency for each initializer, measured as 99th percentile over last 5 minutes</td>\\n<td><a href=\\\"./api_extensions_latency.md\\\">Details</a></td>\\n</tr>\\n</tbody>\\n</table>\"},\"site\":{\"siteMetadata\":{\"sigs\":[\"sig-api-machinery\",\"sig-apps\",\"sig-architecture\",\"sig-auth\",\"sig-autoscaling\",\"sig-aws\",\"sig-azure\",\"sig-big-data\",\"sig-cli\",\"sig-cloud-provider\",\"sig-cluster-lifecycle\",\"sig-cluster-ops\",\"sig-contributor-experience\",\"sig-docs\",\"sig-gcp\",\"sig-ibmcloud\",\"sig-instrumentation\",\"sig-multicluster\",\"sig-network\",\"sig-node\",\"sig-openstack\",\"sig-product-management\",\"sig-release\",\"sig-scalability\",\"sig-scheduling\",\"sig-service-catalog\",\"sig-storage\",\"sig-testing\",\"sig-ui\",\"sig-vmware\",\"sig-windows\"]}}},\"pathContext\":{\"slug\":\"/sig-scalability/slos/slos/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---sig-scalability-slos-slos-db7743e48348a88c17d7.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>Kubernetes scalability and performance SLIs/SLOs</h1>\\n<h2>What Kubernetes guarantees?</h2>\\n<p>One of the important aspects of Kubernetes is its scalability and performance\\ncharacteristic. As Kubernetes user or operator/administrator of a cluster\\nyou would expect to have some guarantees in those areas.</p>\\n<p>The goal of this doc is to organize the guarantees that Kubernetes provides\\nin these areas.</p>\\n<h2>What do we require from SLIs/SLOs?</h2>\\n<p>We are going to define more SLIs and SLOs based on the most important indicators\\nin the system.</p>\\n<p>Our SLOs need to have the following properties:</p>\\n<ul>\\n<li><b> They need to be testable </b> <br/>\\nThat means that we need to have a benchmark to measure if it's met.</li>\\n<li><b> They need to be understandable for users </b> <br/>\\nIn particular, they need to be understandable for people not familiar\\nwith the system internals, i.e. their formulation can't depend on some\\narcane knowledge.</li>\\n</ul>\\n<p>However, we may introduce some internal (for developers only) SLIs, that\\nmay be useful for understanding performance characterstic of the system,\\nbut for which we don't provide any guarantees for users and thus may not\\nbe fully understandable for users.</p>\\n<p>On the other hand, we do NOT require that our SLOs:</p>\\n<ul>\\n<li>are measurable in a running cluster (though that's desired if possible) <br/>\\nIn other words, not SLOs need to be easily translatable to SLAs.\\nBeing able to benchmark is enough for us.</li>\\n</ul>\\n<h2>Types of SLOs</h2>\\n<p>While SLIs are very generic and don't really depend on anything (they just\\ndefine what and how we measure), it's not the case for SLOs.\\nSLOs provide guarantees, and satisfying them may depend on meeting some\\nspecific requirements.</p>\\n<p>As a result, we build our SLOs in \\\"you promise, we promise\\\" format.\\nThat means, that we provide you a guarantee only if you satisfy the requirement\\nthat we put on you.</p>\\n<p>As a consequence we introduce the two types of SLOs.</p>\\n<h3>Steady state SLOs</h3>\\n<p>With steady state SLOs, we provide guarantees about system's behavior during\\nnormal operations. We are able to provide much more guarantees in that situation.</p>\\n<pre><code class=\\\"language-Definition\\\">We define system to be in steady state when the cluster churn per second is &#x3C;= 20, where\\n\\nchurn = #(Pod spec creations/updates/deletions) + #(user originated requests) in a given second\\n</code></pre>\\n<h3>Burst SLO</h3>\\n<p>With burst SLOs, we provide guarantees on how system behaves under the heavy load\\n(when user wants the system to do something as quickly as possible not caring too\\nmuch about response time).</p>\\n<h2>Environment</h2>\\n<p>In order to meet the SLOs, system must run in the environment satisfying\\nthe following criteria:</p>\\n<ul>\\n<li>Runs a single or more appropriate sized master machines</li>\\n<li>Main etcd running on master machine(s)</li>\\n<li>Events are stored in a separate etcd running on the master machine(s)</li>\\n<li>Kubernetes version is at least X.Y.Z</li>\\n<li>...</li>\\n</ul>\\n<p><strong>TODO: Document other necessary configuration.</strong></p>\\n<h2>Thresholds</h2>\\n<p>To make the cluster eligible for SLO, users also can't have too many objects in\\ntheir clusters. More concretely, the number of different objects in the cluster\\nMUST satisfy thresholds defined in <a href=\\\"https://github.com/kubernetes/community/blob/master/sig-scalability/configs-and-limits/thresholds.md\\\">thresholds file</a>.</p>\\n<h2>Kubernetes SLIs/SLOs</h2>\\n<p>The currently existing SLIs/SLOs are enough to guarantee that cluster isn't\\ncompletely dead. However, the are not enough to satisfy user's needs in most\\nof the cases.</p>\\n<p>We are looking into extending the set of SLIs/SLOs to cover more parts of\\nKubernetes.</p>\\n<pre><code>Prerequisite: Kubernetes cluster is available and serving.\\n</code></pre>\\n<h3>Steady state SLIs/SLOs</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>Status</th>\\n<th>SLI</th>\\n<th>SLO</th>\\n<th>User stories, test scenarios, ...</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><strong>Official</strong></td>\\n<td>Latency\\n<sup>\\n<a href=\\\"#footnote1\\\">1</a>\\n</sup>\\n of mutating\\n<sup>\\n<a href=\\\"#footnote2\\\">2</a>\\n</sup>\\n API calls for single objects for every (resource, verb) pair, measured as 99th percentile over last 5 minutes</td>\\n<td>In default Kubernetes installation, for every (resource, verb) pair, excluding virtual and aggregated resources and Custom Resource Definitions, 99th percentile per cluster-day\\n<sup>\\n<a href=\\\"#footnote3\\\">3</a>\\n</sup>\\n &#x3C;= 1s</td>\\n<td><a href=\\\"./api_call_latency.md\\\">Details</a></td>\\n</tr>\\n<tr>\\n<td><strong>Official</strong></td>\\n<td>Latency\\n<sup>\\n<a href=\\\"#footnote1\\\">1</a>\\n</sup>\\n of non-streaming read-only\\n<sup>\\n<a href=\\\"#footnote3\\\">4</a>\\n</sup>\\n API calls for every (resource, scope\\n<sup>\\n<a href=\\\"#footnote4\\\">5</a>\\n</sup>\\n) pair, measured as 99th percentile over last 5 minutes</td>\\n<td>In default Kubernetes installation, for every (resource, scope) pair, excluding virtual and aggregated resources and Custom Resource Definitions, 99th percentile per cluster-day (a) &#x3C;= 1s if \\n<code>scope=resource</code>\\n (b) &#x3C;= 5s if \\n<code>scope=namespace</code>\\n (c) &#x3C;= 30s if \\n<code>scope=cluster</code></td>\\n<td><a href=\\\"./api_call_latency.md\\\">Details</a></td>\\n</tr>\\n<tr>\\n<td><strong>Official</strong></td>\\n<td>Startup latency of stateless\\n<sup>\\n<a href=\\\"#footnode6\\\">6</a>\\n</sup>\\n and schedulable\\n<sup>\\n<a href=\\\"#footnote7\\\">7</a>\\n</sup>\\n pods, excluding time to pull images and run init containers, measured from pod creation timestamp to when all its containers are reported as started and observed via watch, measured as 99th percentile over last 5 minutes</td>\\n<td>In default Kubernetes installation, 99th percentile per cluster-day &#x3C;= 5s</td>\\n<td><a href=\\\"./pod_startup_latency.md\\\">Details</a></td>\\n</tr>\\n</tbody>\\n</table>\\n<p><a name=\\\"footnote1\\\">[1]</a>By latency of API call in this doc we mean time\\nfrom the moment when apiserver gets the request to last byte of response sent\\nto the user.</p>\\n<p><a name=\\\"footnote2\\\">[2]</a>By mutating API calls we mean POST, PUT, DELETE\\nand PATCH.</p>\\n<p><a name=\\\"footnote3\\\">[3]</a> For the purpose of visualization it will be a\\nsliding window. However, for the purpose of reporting the SLO, it means one\\npoint per day (whether SLO was satisfied on a given day or not).</p>\\n<p><a name=\\\"footnote4\\\">[4]</a>By non-streaming read-only API calls we mean GET\\nrequests without <code>watch=true</code> option set. (Note that in Kubernetes internally\\nit translates to both GET and LIST calls).</p>\\n<p><a name=\\\"footnote5\\\">[5]</a>A scope of a request can be either (a) <code>resource</code>\\nif the request is about a single object, (b) <code>namespace</code> if it is about objects\\nfrom a single namespace or (c) <code>cluster</code> if it spawns objects from multiple\\nnamespaces.</p>\\n<p><a name=\\\"footnode6\\\">[6]</a>A <code>stateless pod</code> is defined as a pod that doesn't\\nmount volumes with sources other than secrets, config maps, downward API and\\nempty dir.</p>\\n<p><a name=\\\"footnode7\\\">[7]</a>By schedulable pod we mean a pod that can be\\nscheduled in the cluster without causing any preemption.</p>\\n<h3>Burst SLIs/SLOs</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>Status</th>\\n<th>SLI</th>\\n<th>SLO</th>\\n<th>User stories, test scenarios, ...</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>WIP</td>\\n<td>Time to start 30\\n*\\n#nodes pods, measured from test scenario start until observing last Pod as ready</td>\\n<td>Benchmark: when all images present on all Nodes, 99th percentile &#x3C;= X minutes</td>\\n<td><a href=\\\"./system_throughput.md\\\">Details</a></td>\\n</tr>\\n</tbody>\\n</table>\\n<h3>Other SLIs</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>Status</th>\\n<th>SLI</th>\\n<th>User stories, ...</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>WIP</td>\\n<td>Watch latency for every resource, (from the moment when object is stored in database to when it's ready to be sent to all watchers), measured as 99th percentile over last 5 minutes</td>\\n<td>TODO</td>\\n</tr>\\n<tr>\\n<td>WIP</td>\\n<td>Admission latency for each admission plugin type, measured as 99th percentile over last 5 minutes</td>\\n<td><a href=\\\"./api_extensions_latency.md\\\">Details</a></td>\\n</tr>\\n<tr>\\n<td>WIP</td>\\n<td>Webhook call latency for each webhook type, measured as 99th percentile over last 5 minutes</td>\\n<td><a href=\\\"./api_extensions_latency.md\\\">Details</a></td>\\n</tr>\\n<tr>\\n<td>WIP</td>\\n<td>Initializer latency for each initializer, measured as 99th percentile over last 5 minutes</td>\\n<td><a href=\\\"./api_extensions_latency.md\\\">Details</a></td>\\n</tr>\\n</tbody>\\n</table>\"},\"site\":{\"siteMetadata\":{\"sigs\":[\"sig-api-machinery\",\"sig-apps\",\"sig-architecture\",\"sig-auth\",\"sig-autoscaling\",\"sig-aws\",\"sig-azure\",\"sig-big-data\",\"sig-cli\",\"sig-cloud-provider\",\"sig-cluster-lifecycle\",\"sig-cluster-ops\",\"sig-contributor-experience\",\"sig-docs\",\"sig-gcp\",\"sig-ibmcloud\",\"sig-instrumentation\",\"sig-multicluster\",\"sig-network\",\"sig-node\",\"sig-openstack\",\"sig-product-management\",\"sig-release\",\"sig-scalability\",\"sig-scheduling\",\"sig-service-catalog\",\"sig-storage\",\"sig-testing\",\"sig-ui\",\"sig-vmware\",\"sig-windows\"]}}},\"pathContext\":{\"slug\":\"/sig-scalability/slos/slos/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/sig-scalability-slos-slos.json\n// module id = 491\n// module chunks = 196072083135701"],"sourceRoot":""}